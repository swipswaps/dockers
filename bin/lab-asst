#!/bin/bash

# Manage Jupyter lab instances from within the container.

function usage() {
    printf "lab-asst: An assistant for managing Jupyter lab instances.\n\n"
    echo "Usage: $0 [argument]"
    printf "Possible arguments:\n\n"
    printf "%s\t\t%s" "-l" "List all running Jupyter lab instances. Includes time the notebook was opened, "
    printf "CPU usage, and RAM usage.\n"
    printf "%s %s\t\t%s\n" "-s" "[id]" "Stop given Jupyter lab instance gracefully."
    exit
}

function list() {
    echo "Gathering information..."
    OUTPUT=/tmp/output-$RANDOM
    touch $OUTPUT
    echo "PID|PARENT|CPU|MEM|TIME_STARTED|TYPE|DIRECTORY|URL" >> $OUTPUT
    # sed: turn unknown number of whitespace into one space
    # shellcheck disable=SC2009
    ps -axo user,pid,ppid,%cpu,%mem,start_time,args | grep jupyter | grep -v grep | grep "$USER" | sed -r 's/\s+ / /g' | while read -r item
    do
	# shellcheck disable=SC2086
	pid=$(echo $item | cut -d ' ' -f2)
	# shellcheck disable=SC2086
	parent=$(echo $item | cut -d ' ' -f3)
	# shellcheck disable=SC2086
	cpu=$(echo $item | cut -d ' ' -f4)
	# shellcheck disable=SC2086
	mem=$(echo $item | cut -d ' ' -f5)
        # shellcheck disable=SC2086
	time=$(echo $item | cut -d ' ' -f6)
        # shellcheck disable=SC2012
	# shellcheck disable=SC2086
    if [ -d "$(echo $time | egrep '[0-9]+\:[0-9]+')" ]; then
        month=$(echo $time | cut -c1-3)
        day=$(echo $time | cut -c4-)
        time=$("$month $day")
    fi
	working_dir=$(readlink -f /proc/"$pid"/cwd)
        if pgrep -f -P "$parent" ipykernel_launcher 2> /dev/null >/dev/null; then
            type="kernel"
        else
            type="notebook"
            container_id=$(docker ps | awk '{ print $1 }' | grep -v "CONTAINER" \
            | xargs docker inspect -f '{{.State.Pid}} {{.Id}}' | grep "$parent" | cut -d ' ' -f2)
            orig_proc=$(docker exec -u "$USER" "$container_id"  /bin/ps -axo pid,ppid,args | grep jupyter-lab | grep -v grep | awk '{print $1}')
            # port number needed to determine what URL this notebook is using, pulled from config file
            # shellcheck disable=SC2010
            file="/home/$USER/.local/share/jupyter/runtime/nbserver-$orig_proc.json"
            # shellcheck disable=SC2116
	    # shellcheck disable=SC2002
	    token=$(cat "$file" 2>/dev/null | grep token | cut -d ':' -f2- | tr -d '"' | tr -d ' ' | tr -d ',')
	    # shellcheck disable=SC2002
	    part_url=$(cat "$file" 2>/dev/null | grep http | cut -d ':' -f2- | tr -d '"' | tr -d ' ')
            url="$part_url?token=$token"

        fi
        if [ "$type" == "kernel" ]; then
            echo "$pid|$parent|$cpu|$mem|$time|$type|$working_dir" >> $OUTPUT
        else
            echo "$pid|$parent|$cpu|$mem|$time|$type|$working_dir|$url" >> $OUTPUT
        fi
    done
    # organize output into columns
    # shellcheck disable=SC2002
    cat $OUTPUT | column -t -s "|"
}

function stop() {
    echo "Attempting to stop process gracefully..."
    kill "$1"
    sleep 2
    # if pid is still around, prompt user for decision
    # shellcheck disable=SC2009
    # shellcheck disable=SC2086
    if ps -aux | grep $1 | grep jupyter 2>/dev/null >/dev/null; then
        echo "Warning: this notebook is not gracefully closing, which usually means that you have unsaved work."
        echo "It is recommended that you save your work and close manually."
        printf "Would you like to forcefully close the notebook? (y/N) "
        read -r answer
        if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
            echo "Force closing process..."
            kill -9 "$1"
        else
            return
        fi

    else
        return
    fi
}

if [ $# -lt 1 ]; then
    usage
    exit
fi

while getopts ":ls:" options; do
    case "${options}" in
        l)
            list
            ;;
        s)
            stop "$2"
            ;;
        :)
            echo "Error: -${OPTARG} requires an argument."
            usage
            ;;

        *)
            echo "$options"
            usage
            ;;
    esac
done
