#!/bin/bash

# Manage Jupyter lab instances from within the container.

function usage() {
    printf "lab-asst: An assistant for managing Jupyter lab instances.\n\n"
    echo "Usage: $0 [argument]"
    printf "Possible arguments:\n\n"
    printf "%s\t\t%s" "-l" "List all running Jupyter lab instances. Includes time the notebook was opened, "
    printf "CPU usage, and RAM usage.\n"
    printf "%s %s\t\t%s\n" "-s" "[id]" "Stop given Jupyter lab instance gracefully."
    exit
}

function list() {
    echo "Gathering information..."
    # array item separator is newline instead of space
    local IFS=$'\n'
    OUTPUT=/tmp/output
    # sed: turn unknown number of whitespace into one space
    running=$(ps -axo pid,ppid,%cpu,%mem,start_time,args | grep jupyter | grep -v grep | sed -r 's/\s+ / /g')
    echo "PID PARENT CPU MEM TIME_STARTED TYPE DIRECTORY URL" >> $OUTPUT
    for item in ${running[@]}; do
        pid=$(echo $item | cut -d ' ' -f2)
        parent=$(echo $item | cut -d ' ' -f3)
        cpu=$(echo $item | cut -d ' ' -f4)
        mem=$(echo $item | cut -d ' ' -f5)
        time=$(echo $item | cut -d ' ' -f6)
        working_dir=$(ls -lad /proc/$pid/cwd | cut -d ' ' -f11)
        grep_test=$(ps -aux | grep $pid | grep -v grep | sed -r 's/\s+ / /g' | grep ipykernel_launcher)
        if [ $? -eq 0 ]; then
            type="kernel"
        else
            type="notebook"
            # port number needed to determine what URL this notebook is using, pulled from config file
            # that corresponds to listening port number
            port=$(lsof -p $pid 2>/dev/null | grep LISTEN | cut -d ':' -f2 | cut -d ' ' -f1)
            file="/home/$USER/.local/share/jupyter/runtime/nbserver-$pid.json"
            token=$(cat $file 2>/dev/null | grep token | cut -d ':' -f2- | tr -d '"' | tr -d ' ' | tr -d ',')
            part_url=$(cat $file 2>/dev/null | grep http | cut -d ':' -f2- | tr -d '"' | tr -d ' ')
            url="$part_url?token=$token"

        fi
        if [ "$type" == "kernel" ]; then
            echo "$pid $parent $cpu $mem $time $type $working_dir" >> $OUTPUT
        else
            echo "$pid $parent $cpu $mem $time $type $working_dir $url" >> $OUTPUT
        fi
    done
    # organize output into columns
    cat $OUTPUT | column -t
    rm /tmp/output
}

function stop() {
    echo "Attempting to stop process gracefully..."
    kill $1
    sleep 2
    result=$(ps -aux | grep $1 | grep jupyter)
    # if pid is still around, prompt user for decision
    if [ $? -eq 0 ]; then
        echo "Warning: this notebook is not gracefully closing, which usually means that you have unsaved work."
        echo "It is recommended that you save your work and close manually."
        printf "Would you like to forcefully close the notebook? (y/N) "
        read answer
        if [ "$answer" == "y" -o "$answer" == "Y" ]; then
            echo "Force closing process..."
            kill -9 $1
        else
            return
        fi

    else
        return
    fi
}

if [ $# -lt 1 ]; then
    usage
    exit
fi

while getopts ":ls:" options; do
    case "${options}" in
        l)
            list
            ;;
        s)
            stop $2
            ;;
        :)
            echo "Error: -${OPTARG} requires an argument."
            usage
            ;;
        
        *)
            echo $options
            usage
            ;;
    esac
done